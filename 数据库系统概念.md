# 数据库系统概念

## 数据库系统概述

### 数据与数据管理技术

#### 数据库基本概念

##### 数据与信息：

数据是描述事物的符号记录，是指用物理符号记录下来的、可以鉴别的信息。

信息是有一定含义的、经过加工处理的、对决策有价值的数据。

数据是信息的载体，信息是数据的内涵。

数据处理也称为信息处理，是指对各种形式的数据进行收集、存储、传播和加工直至产生新信息输出的全过程。

数据管理是数据处理的中心问题，是指数据的收集、整理、组织、存储、查询、维护和传送等各种操作，也是数据处理的基本环节，是数据处理必有得共性部分。

##### 数据库（DB）：

数据库（DB）是按照一定结构组织并长期存储在计算机内的、可共享的大量数据得集合。

数据库中存储的数据具有**永久存储**、**有组织**和**可共享**三个基本特点。

##### 数据库管理系统（DBMS）：

数据库管理系统（DBMS）是位于用户与操作系统之间的一层数据管理软件，安装与操作系统之上，是一个管理、控制数据库中各种数据库对象的系统软件。

数据库管理系统是数据库系统的一个重要组成部分。

###### 主要功能：

1.**数据定义功能**：DBMS提供数据定义语言（DDL），定义数据库中的数据对象。

例：表、视图、存储过程、触发器等

2.**数据操纵功能**：DBMS停工数据操纵语言（DML）操纵数据实现对数据可的基本操作。

例：查询、插入、删除、修改等

3.**数据库的运行管理**：保证数据的安全性、完整性、多用户对数据的并发使用以及发生故障后的系统恢复

4.数据库的建立和维护功能：创建数据库及对数据库空间的维护、数据库的备份与恢复功能、数据库的重组织功能和性能监视、分析等

5.数据组织、存储和管理功能

例：索引查找、顺序查找

6.其他功能：主要包括与其他软件的网络通信功能、不同数据库管理系统之间的数据传输以及相互访问功能等

##### 数据库系统（DBS）：

数据库系统（DBS）是指计算机引入数据库后的系统，，它能够有组织地、动态地存储大量的数据，提供数据处理和数据共享机制。

通常一个完整的数据库系统包括**数据库**、**数据管理系统**及相**关实用工具**、**应用程序**、**数据库管理员**和**用户**。

数据库管理员（DBA）是专门负责对数据库进行维护，并保证数据库正常、高效运行。

数据库系统是最大的。

#### 数据管理技术的发展

##### 人工管理阶段：

特点：

1.数据不保存

2.应用程序管理数据

3.数据面向应用

**记录内无结构，整体无结构**

##### 文件系统阶段：

特点：

数据的管理者：文件系统，**数据可长期保存**

数据面向的对象：某一应用程序

数据的共享程度：**共享性差、冗余度大**

数据的结构化：**记录内用结构，整体无结构**

数据的独立性：**独立性差**，数据的逻辑结构改变必须修改应用程序

数据控制能力：应用程序自己控制

##### 数据库系统阶段：

特点：**1.数据集成							2.数据共享性高**

​			**3.数据冗余小						4.数据一致性**

​			**5.数据独立性高**					**6.实施统一管理与控制**

​			7.减少应用程序开发与维护的工作量

![数据管理3个阶段的比较](https://img-blog.csdnimg.cn/20191103183545415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbGlsaWxpbGlsaWtp,size_16,color_FFFFFF,t_70)

### 数据库系统的特点及组成

#### 数据库系统的特点：

1.数据结构化

2.数据的共享性高，冗余度低，易扩充

3.数据独立性高：数据独立性包括物理独立性和逻辑独立性

逻辑独立性指用户的应用程序与数据库的逻辑结构式相互独立的

4.数据由DBMS统一管理和控制：

数据由DBMS统一管理和控制，用户和应用程序通过DBMS访问和使用数据库

##### DBMS数据控制功能

1.数据的安全性保护

2.数据的完整性检查

3.并发控制

4.数据库恢复



### 数据库系统结构

#### 三级模式结构：

数据库系统内部的体系结构通常采用三级模式结构，即有外模式、模式和内模式组成

##### 模式：

模式也称为概念模式或逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公有数据库结构。

特性：

1.一个数据库只有一个模式

2.模式与具体应用程序无关，它只是装配数据的一个框架

3.模式用语言描述和定义，需定义数据的逻辑结构、数据有关的安全性等

##### 外模式：

外模式也称为子模式或用户模式，是数据库用户所见和使用的局部数据的逻辑结构和特征的描述，是用户所用的数据库结构

特性：

1.一个数据库可以有多个外模式；每个用户至少使用一个外模式

2.同一个用户可使用不同的外模式，而每个外模式可为不同的用户所用

3.模式是对全体用户数据及其关系的综合与抽象，外模式是根据所需对模式的抽取

##### 内模式：

内模式也称为存储模式，是数据物理结构的存储方法的描述。它是整个数据库的最底层结构的表示。

特性：
1.一个数据库只有一个内模式。内模式对用户透明

2.一个数据库由多种文件组成，如用户数据文件、索引文件及系统文件等

3.内模式设计直接影响数据库的性能

##### 模式关系：

以物理模式为框架的数据库称为物理数据库。在数据库系统中，只有物理数据库才是真正存在的，它是存储在外存的实际数据文件；而概念数据库和用户数据库在计算机外存是不存在的。

1.概念数据库是物理数据库的逻辑抽象形式

2.物理数据库是概念数据库的具体实现

3.用户数据库是概念数据库的子集，也是物理数据库子集的逻辑描述

##### 数据独立性与二级映像功能：

数据独立性是指数据与程序间的互不依赖性，一般分为**物理独立性**与**逻辑独立性**

（1）外模式/模式映像（逻辑独立性）

（2）模式/内模式映像（物理独立性）

两级映像特性：

1.模式/内模式映像是唯一的

2.子模式/模式映像不唯一

##### 三级模式结构与两层映像的优点：

1.保证数据的独立性

2.方便用户使用，简化用户接口

3.保证数据库安全性的一个有力措施

4.有利于数据的共享性

5.有利于从宏观上通俗地理解数据库系统地内部结构

#### 数据库系统体系结构：

##### 客户/服务器结构（C/S）结构：

C/S结构的基本原则是将计算机应用任务分解成多个子任务，由多台计算机分工完成，即采用“功能分布”原则

##### 浏览器/服务器（B/S）结构：

B/S最大优点是可以在任何地方进行操作而不用安装任何专门的软件，客户端零安装、零维护。B/S结构推动了AJAX技术的发展，它的程序也能在客户端计算机上进行部分处理，从而大大地减轻了服务器的负担；并增加了交互性，能进行局部实时刷新

## 信息与数据模型

数据库系统的核心是数据模型。为一个数据库建立数据模型，需经过以下过程：

1.要深入到现实世界中进行系统需求分析

2.用概念模型真实地、全面地描述现实世界中地管理对象及联系

3.通过一定地方法将概念模型转换为数据模型

常见地数据模型有层次模型、网状模型、关系模型和面向对象模型

### 信息地三种世界及描述

将客观事物抽象为能用计算机存储和处理地数据需经历三个阶段：现实世界，信息世界，计算机世界（数据世界）

##### 现实世界：

现实世界客观存在的世界，在数据库中指的是对某一事物的描述，描述其各方面特征以及是否与其他事物存在联系

##### 信息世界：

信息世界是对客观事物的抽象描述，是对现实世界经过分析、归纳和抽象得到的信息，这样的信息具有一定的格式。

##### 计算机世界：

计算机世界是对信息世界的再一次抽象，将其信息化，使得信息能够存储在计算机中

这三个领域是由客观到认识，由认识到使用管理地3个不同层次，后一领域是前一领域地抽象描述

![三个世界，两级抽象](https://img-blog.csdnimg.cn/2020081014493058.png#pic_center)<img src="C:\Users\24394\AppData\Roaming\Typora\typora-user-images\image-20201106134653255.png" alt="image-20201106134653255" style="zoom: 50%;" />

现实世界地事物及联系，通过需求分析转换成为信息世界地概念模型，这个过程由数据库设计人员完成；然后再把概念模型转换为计算机上某个DBMS所支持地逻辑模型，这个过程由数据库设计人员和DBMS共同完成；最后逻辑模型再转换为最底层地物理模型，最终实现，这个过程由DBMS自行完成

### 数据模型

#### 数据模型的概念：

数据模型是对现实世界中数据特征及数据之间联系的抽象。

数据模型用来描述数据组成、数据关系、数据约束的抽象结构及其说明和对数据进行操作。

数据模型是实现数据抽象的主要工具。

数据模型是数据库系统的核心和基础，决定了数据库系统的结构、数据定义语言和数据操作语言、数据库设计方法、数据库管理系统软件的设计和实现。

数据模型应满足：

1.能比较真实地模拟现实世界

2.容易为人所理解

3.便于在计算机上实现

#### 数据处理三层抽象描述：

##### 概念层：

概念层是数据抽象级别的最高层，其目的是按用户的观点来对现实世界建模

常用的概念模型有E-R模型

##### 逻辑层：

逻辑层是数据抽象的中间层，描述数据库数据整体的逻辑结构

常见的数据模型有层次模型、网状模型、关系模型和面向对象模型

##### 物理层：

物理层是数据抽象的最底层，用来描述数据物理存储结构和存储方法

#### 数据模型的要素：

数据模型通常由数据结构、数据操作和完整性约束组成

##### 数据结构：

数据结构描述数据库的组成对象以及对象之间的联系。

数据结构是所描述的对象类型的集合，是对系统**静态特性**的描述

静态特性：数据对象的数据类型、内容、属性以及数据对象之间的联系

##### 数据操作：

数据操作是指对数据库中各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。

数据操作是对系统**动态特性**的描述。

##### 数据的完整性约束条件：

数据的完整性约束条件是一组完整性规则。

完整性规则主要描述数据结构中数据之间的语义联系、数据之间的制约和依存关系，以及数据动态变化规则。

数据约束主要用于保证数据的**完整性**、**有效性**、**相容性**

#### 数据模型与数据模式的区别：

数据模式：以一定的数据模型对一个单位的数据的类型、结构及其相互间的关系所进行的描述。  有型与值之分。

数据模型和数据模式的主要区别在于数据模型是描述现实世界的手段和工具；数据模式是利用这个手段和工具对相互间的关系所进行的描述。

### 概念模型

#### 基本概念：

实体（Entity）：客观存在并相互区别的事物

属性（Attribute）：实体所具有的某一特性，一个实体由若干个属性刻画

实体型（Entity Type）：用实体类型名和所有属性来共同表示同一类实体

实体集（Entity Set）：同型实体的集合

码（Key）：唯一标识实体的属性集

域（Domain）：属性的取值范围

联系（Relationship）：实体内部的联系（各属性之间的联系）和实体之间的联系（不同实体集之间的联系）

#### E-R模型：

##### 基本概念：	

实体用矩形框表示																					

属性用椭圆框表示

联系用菱形框表示

<img src="C:\Users\24394\AppData\Roaming\Typora\typora-user-images\image-20201106143451551.png" alt="image-20201106143451551" style="zoom: 67%;" />

联系分为：

一对一联系（1：1）；一对多联系（1：n）；多对多联系（m：n）

##### E-R模型设计原则与设计步骤：

###### 设计原则：

1.属性应该存在于且只存在于某一个地方（实体或者关联）

2.实体是一个单独的个体，不能存在于另一个实体中成为其属性

3.同一个实体在同一个E-R图内仅出现一次

###### 设计步骤：

1.划分和确定实体

2.划分和确定联系

3.确定属性：能够作为属性的“事物”尽量作为属性处理

4画出E-R模型：重复1~3，找出所有实体集、关系集、属性和属值集，绘制E-R图。

5.优化E-R模型：消除数据实体间冗余的联系及属性

### 逻辑模型

#### 层次模型：

用**树形结构**表示各类实体以及实体间的联系

适用于表示记录类型之间的一对多联系，而对于多对多的联系难以直接表示

优缺点：

1.数据结构简单，查询效率高

2.提供良好的完整性支持

3.不易表示多对多的联系

4.数据操作限制多、独立性较差

5.节点的双亲是唯一的（每节点只有一个副节点）

#### 网状模型：

用**图结构**表示各类实体集以及实体集间的联系

网状模型允许节点由多个双亲节点，允许多个节点没有双亲节点

一个子节点可以有多个父节点；在两个节点之间可以有多种联系

对于多对多的联系难以直接表示

优缺点：

1.较为直接地描述现实世界

2.存储效率较高

3.结构较复杂、不易使用

4.数据独立性较差

#### 关系模型：

是最重要的一种基本模型，也是目前应用最广泛的数据模型

关系就是一张二维表，有行和列组成

在关系模型中实体以及实体之间的联系都用关系即**二维表**表示

优缺点：

1.有坚实的理论基础

2.结构简单、易用

3.数据具有较强的独立性及安全性

4.查询效率较低

#### 面向对象模型：

是用**面向对象**的观点来描述现实世界中的事物（对象）的逻辑结构和对象间的联系等的数据结构

对象：对现实世界中的事物的高度抽象，每个对象是状态和行为的封装

对象的状态是属性的集合，行为是在该对象上操作方法的集合

优缺点：

1.适合处理各种各样的数据类型：面向对象数据库适合存储不同类型的数据，例如图片、声音、视频，包括文本、数字等

2.面向对象程序设计于数据库技术相结合

3.提高开发效率：面向对象数据模型提供强大的特性，例如继承、多态和动态绑定，允许用户不用编写特定对象的代码就可以构成对象并提供解决方案

4.改善数据访问：支持导航式和关联式两种方式的信息访问，比基于关系值得联系更能提高数据访问性能

5.没有准确的定义

6.维护困难

7.不适合所有的应用

### 概念模型向逻辑模型的转换

#### 实体的转换：

实体转换为关系模型，一个实体对应一个关系模型，实体的名称即是关系模型的名称，实体的属性就是关系模型的属性，实体的码就是关系模型的码

#### 联系的转换：

##### 1   ：1转换：

方法一：将1：1联系转换成一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系模式的属性，**每个实体的码均是该关系模式的码**

方法二：与任意一端对应的关系模式合并。合并时，在该关系模式的属性中应加入**另一个关系模式的码**和**联系本身的属性**

例：学生（<u>学号</u>，姓名）

​		校园卡（<u>卡号</u>，余额）

​		学生办卡有办卡日期

方法一转换后：

​		实体转换：学生（<u>学号</u>，姓名）   校园卡（<u>卡号</u>，余额）

​		联系转换：办卡（<u>学号</u>，<u>卡号</u>，办卡日期）

方法二转换后：

​		学生（<u>学号</u>，<u>卡号</u>，姓名，办卡日期）或

​		校园卡（<u>卡号</u>，<u>学号</u>，余额，办卡日期）

##### 1   ：n转换：

方法一：转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系模式的属性，而**关系模式的码为n端实体的码**

方法二：与n端对应的关系模式合并，在该关系模式中加入**1端实体的码**和**联系本身的属性**

例：学生（<u>学号</u>，性别，姓名）

​		班级（<u>班号</u>，班名）

​		一个学生只能在一个班级学习，一个班级包含多个学生，班级：学生=1：n

方法一转换后：

​		实体转换：学生（<u>学号</u>，性别，姓名）   班级（<u>班号</u>，班名）

​		联系转换：组成（<u>学号</u>，班号）

方法二转换后：
		实体转换：学生（<u>学号</u>，性别，姓名）   班级（<u>班号</u>，班名）

​		联系转换：与学生一端合并，学生（<u>学号</u>，<u>班号</u>，性别，姓名）

##### m  ：n转换：

将联系单独转换为一个独立的关系模式，与该联系相连的各实体的码以及联系本身的属性均转换为关系模式的属性，每个实体的码组成关系模式的码或关系模式的码的一部分

例：学生（<u>学号</u>，性别，姓名）

​		课程（<u>课程号</u>，课程名）

​		一个学生可以选修多门课程，一门课程可以由多个学生选修。   学生：课程=m：n

​		转换后：

​		实体转换： 学生（<u>学号</u>，性别，姓名）	课程（<u>课程号</u>，课程名）

​		联系转换：选修（<u>学号</u>，<u>课程号</u>，成绩）

具有相同码的关系模式将其中一个关系模式的属性都加到另一个关系模式中，去掉同义属性

### 关系模型

关系模型的数据结构为具有一定特征的二维表。

在关系数据库中，数据以关系表形式存储实体数据，关系是一个由行和列组成的二维表

#### 关系数据结构：

##### 基本术语：

###### 表（Table）

表，也称为关系，是一个二维的数据结构，由表名、构成表的各个列及若干行数据组成

###### 关系（Relation）

一个关系逻辑上对应一张二维表，可以为每个关系取一个名称进行标识，即表名

###### 列（Column）

列，也称为字段或属性，每一列有一个名称，每一列表示实体的一个属性，具有相同的数据类型

###### 属性（Attribute）

一列即一个属性，表中属性的个数称为关系的元或度，列的值称为属性值，属性值得取值范围为值域

###### 行（Row）

行即元组或记录

###### 元组（Tuple）

表中得一行即为一个元组

###### 分量（Component）

元组中的一个属性值，组成元组的元素

###### 码或键（Key）

在一个关系中，存在这样的属性（或属性组）使得在该关系的任何一个关系状态中的两个元组，在该属性（或属性组）上值得组合都不相同，即这些属性（或属性组）的值都能用来**唯一标识该关系的元组**，这属性（或属性组）即为码

###### 超码或超键（Super Key）

如果在关系的一个码中移去某个属性，它仍然是这个关系的码，即为超键

###### 候选码或候选键（Candidate Key）

若关系中的某一属性（或属性组）的值能唯一标识一个元组，则称该属性（或属性组）为候选码

###### 主码（Primary Key）

在一个关系的若干个候选码中指定一个用来唯一标识关系的元组，则指定的即为主码

当包含两个或多个的键称为**复合码**

主码的作用：

- 唯一标识关系的每行
- 作为关联表的外键，链接两个表
- 使用主码值来组织关系的存储
- 使用主码索引快速检索数据

###### 全码（All-Key）

一个关系模式的所有属性集合是这个关系的主码，则这样的主码为全码

###### 主属性（Primary Attribute）和非主属性（Nonprimary Attribute）

关系中包含在任何一个候选码中的属性称为主属性，不包含在任何一个候选码中的属性称为非主属性

###### 代理键

代理键是具有DBMS分配的唯一标识符，每次创建行时由DBMS分配代理键的唯一值

###### 外码或外键（Foreign Key）

当关系中的某个属性（或属性组）不是这个关系的主码或候选码，而是另一关系的主码时，则该属性为外键

外码并不一定要与相应的主码同名

###### 参照关系（Referencing Relation）和被参照关系（Referenced Relation）

参照关系即从关系，被参照关系即主关系，值以外码相关联的两个关系。以外码作为主键的关系称为被参照关系；外码所在的关系称为参照关系，被参照关系与参照关系是通过外码相联系的，这种联系通常时一对多的联系

###### 域（Domain）

属性的取值范围

###### 数据类型（Data Type）

表中每列都有相应的数据类型，它用于限制该列中存储的数据

##### 关系类型(Relation Type)

关系类型有三类：**基本关系**（基本表或基表）、**查询表**和**视图表**

基本表：是实际存在的表，是实际存储数据的逻辑表示

查询表：是查询结果表或查询中生成的临时表

视图表：是由基本表或其他视图表导出的表，是**虚表**，不对应实际存储的数据

##### 关系模式（Relation Schema）

数据库有型和值之分。在关系数据库中，关系模式是型，关系是值，即关系模式是对关系的描述。关系模式是对关系的描述。关系模式是静态的，稳定的，而关系是动态的、随时间不断变化的。

关系模式可以表示为五元组R(U,D,Dom,F)

- R：关系名
- U：组成该关系的属性的集合
- D：属性组U中的属性所来自的域
- Dom：属性向域的映像集合
- F：属性间数据依赖关系的集合

五元组可以简化为二元组R(U)

##### 关系数据库（Relation Database）

关系数据库是以关系模型作为数据的逻辑模型

#### 关系操作

##### 基本的关系操作

关系操作包括**数据查询**、**数据维护**和**数据控制**

数据控制是为了保证数据的安全性和完整性而采用的**数据存取控制**和**并发控制**等功能

###### 查询

选择、投影、连接、除、并、交、差、笛卡尔积

###### 数据更新

插入、删除、修改

查询的表达能力很强，是其中最主要的部分

###### 关系操作的特点

集合操作方式，即操作的对象和结果都是集合

#### 关系操作语言的分类

关系操作的能力可以用两种方式来表示：**代数方式**和**逻辑方式**

代数方式主要有**关系代数**，它是通过对关系的操作来表达查询要求的方式

逻辑方式主要有**关系演算**，它是用谓词来表达查询要求的方式

具有关系代数和关系演算双重特点的语言 如SQL

这些语言都具有的特点：

- 具有完备的表达能力
- 是非过程化的集合操作语言
- 功能强
- 能够嵌入高级语言使用

#### 关系的完整性约束

##### 实体完整性约束

实体完整性约束是指关系的主属性，即主码的组成不能为空，即主属性不能是空值NULL

##### 参照完整性约束

现实世界中的实体之间往往存在的某种联系

若属性（或属性组）F是基本关系R的外码，它域基本关系S的主码Ks相对应（R和S有可能是同一关系），则对于R中每个元组在F上的值必须为

- 空值
- 等于S中某个元组的主码值

##### 用户完整性约束

用户定义的完整性约束是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求

## 关系代数与关系数据库理论

### 关系代数及其运算

关系查询语言分为：

关系代数语言：用关系的运算来表达查询要求的方式，查询操作是以集合操作位基础运算的DML语言

关系演算语言：用谓词来表达查询要求的方式，查询操作是以谓词演算为基础运算的DML语言。

#### 关系代数运算符

##### 集合运算符

| 运算符 | 含义     | 英文              |
| :----- | :------- | :---------------- |
| ∪      | 并       | Union             |
| −      | 差       | Difference        |
| ∩      | 交       | Intersection      |
| ×      | 笛卡尔积 | Cartesian Product |

##### 比较运算符

| 运算符 | 含义     |
| :----- | :------- |
| >      | 大于     |
| ≥      | 大于等于 |
| <      | 小于     |
| ≤      | 小于等于 |
| =      | 等于     |
| ≠      | 不等于   |

##### 专门的关系运算符

| 运算符 | 含义 | 英文       |
| :----- | :--- | :--------- |
| σ      | 选择 | Selection  |
| π      | 投影 | Projection |
| ⋈      | 链接 | Join       |
| ÷      | 除   | Division   |

##### 逻辑运算符

| 运算符 | 含义 |
| :----- | :--- |
| ∧      | 与   |
| ∨      | 或   |
| ¬      | 非   |



##### 基本的关系代数运算

###### 并（Union）

关系 R 与 S 具有相同的关系模式，即 R 与 S 的元数相同（结构相同），R 与 S 的并是属于 R 或者属于 S 的元组构成的集合，记作 R ∪ S，定义如下：

R∪S={t|t∈R∨t∈S}R∪S={t|t∈R∨t∈S}

###### 差（Difference）

关系 R 与 S 具有相同的关系模式，关系 R 与 S 的差是属于 R 但不属于 S 的元组构成的集合，记作 R − S，定义如下：

R−S={t|t∈R∨t∉S}R−S={t|t∈R∨t∉S}

###### 交（Intersection）

关系 R 和 S 具有相同的关系模式，交是由属于 R 同时双属于 S 的元组构成的集合，记作 R∩S，形式如下：

R∩S={t|t∈R∧t∈S}R∩S={t|t∈R∧t∈S}

###### 广义笛卡尔积（Extended Cartesian Product）

两个无数分别为 n 目和 m 目的关系 R 和 S 的 笛卡尔积是一个 (n+m) 列的元组的集合。组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组，记作 R × S，定义如下：

R×S={t|t=<(T<sub >n</sub>,T<sub >m</sub>)∧T<sub >n</sub>∈R∧T<sub >m</sub>∈S}R×S={t|t=<(T<sub >n</sub>,T<sub >m</sub>)∧T<sub >n</sub>∈R∧T<sub >m</sub>∈S}

$(t^n,t^m)$ 表示元素 $t^n$ 和 $t^m$ 拼接成的一个元组

**注：新关系中属性的个数为n+m，元组的个数为k1×k2.**

##### 投影（Projection）

投影运算是从关系的垂直方向进行运算，在关系 R 中选出若干属性列 A 组成新的关系，记作 $π_A(R)$，其形式如下：

πA(R)={t[A]|t∈R}πA(R)={t[A]|t∈R}

##### 选择（Selection）

选择运算是从关系的水平方向进行运算，是从关系 R 中选择满足给定条件的元组，记作 $σ_F(R)$，其形式如下：

σF(R)={t|t∈R∧F(t)=True}σF(R)={t|t∈R∧F(t)=True}

###### 实例

设有关系 R、S 如图所示，求 $R∪S$、 $R−S$、 $R×S$、 $π_{A,C}(R)$、 $σ_{A>B}(R)$ 和 $σ_{3<4}(R×S)$

![关系表RS](https://img10.360buyimg.com/devfe/jfs/t3967/269/2409299226/5377/e997b909/58a95fceNddd39fd7.png)

进行并、差运算后结果如下：

![并差](https://img14.360buyimg.com/devfe/jfs/t3949/95/2458170516/5487/1c7f1f38/58a967b1N42db123f.png)

进行笛卡尔、 投影、 选择运算后结果如下：

![笛卡尔_投影_选择](https://img30.360buyimg.com/devfe/jfs/t3943/109/2403665652/38834/c636281b/58a9685dN20af0b9b.png)



##### 链接（Join）

###### 等值链接

当 θ 为「=」时，称之为等值链接，记为： $R\Join_{X=Y}S$

###### 自然链接

自然链接是一种特殊的等值链接，它要求两个关系中进行比较的分量必须是 **相同的属性组**，并且在结果集中将 **重复的属性列** 去掉

例如：设有关系 R、S 如图所示，求 $R \Join S$

![关系RS](https://img11.360buyimg.com/devfe/jfs/t3982/212/2472511181/5973/54467e2a/58aa5ffaN970f7e5a.png)

先求出笛卡尔积 $R×S$，找出比较分量（有相同属性组），即: R.A/S.A 与 R.C/S.C

![求出笛卡尔积](https://img10.360buyimg.com/devfe/jfs/t3841/5/4275908218/12385/79e83d01/58aa6066Nd003e697.png)

取等值链接 $R.A = S.A$ 且 $R.C = S.C$

![找出相同属性的比较分量](https://img10.360buyimg.com/devfe/jfs/t3256/75/6205568741/12327/2b1dc867/58aa60e8N38a84108.png)

结果集中去掉重复属性列，注意无论去掉 R.A 或者 S.A 效果都一样，因为他们的值相等，结果集中只会有属性 A、B、C、D

![结果集中找出重复属性列](https://img12.360buyimg.com/devfe/jfs/t3217/183/6576493853/4744/ccb96965/58aa612eN043f7425.png)

最终得出结果

![RS自然链接结果](https://img12.360buyimg.com/devfe/jfs/t3247/65/6676502314/2874/657ddb0c/58aa617eN2457f536.png)

##### 除（Division）

设有以下如图关系，求 $R÷S$

![关系RS1](https://img10.360buyimg.com/devfe/jfs/t3151/348/6716540896/7287/dc01ad2e/58aaaf3bN1cae8b1a.png)

取关系 R 中有的但 S 中没有的属性组，即：A、B

![关系RS1取属性AB](https://img11.360buyimg.com/devfe/jfs/t3202/137/6722879648/7244/3b47a185/58aaaf81N0b2491b5.png)

取唯一 A、B 属性组值的象集

象集：本质上是一次选择行的运算和一次选择列的运算。
求x1在表A中的象集，就是先选出所有x属性中x=x1的那些行，然后选择出不包含x1的那些列。

![关系RS1取属性AB对应的象集](https://img11.360buyimg.com/devfe/jfs/t3871/170/2430481542/5179/be5899c5/58aaafe6N8297b49f.png)

可知关系S存在于 a,b/c,k 象集 中。即 $R÷S$ 得

![关系RS1除结果](https://img10.360buyimg.com/devfe/jfs/t3130/361/6704334588/3366/6b7e0b56/58aab058N3a3c374d.png)

 **注：当提出查询“全部”，“所有”，“至少”这样的关键字时可以考虑使用除法解决。**

##### 实例：P52

### 关系数据库理论

#### 数据冗余

关系模式中可能存在的冗余和异常问题

1.数据冗余   2.更新异常  3.插入异常  4.删除异常

#### 函数依赖

数据依赖分为：函数依赖、多值依赖、连接依赖

函数依赖与关键字

设R为任一给定关系，如果对于R中属性X的每一个值，R中的属性Y只有唯一值与之对应，则称X函数决定Y或Y函数依赖于X

- 完全函数依赖
  - 如果存在 X 属性集（注意是集合，说明是联合主键）决定唯一的 Y ，且 X 中的任一子集都不能决定唯一的 Y，则 Y 完全依赖于 X。
  - 例如：学生数学成绩完全由该学生的学号和数学课决定，所以数学课成绩完全依赖于（学号，数学课）
- 部分函数依赖
  - X 的属性集中任一子集都可以决定唯一的 Y
  - 例如：学生学号和姓名可以决定唯一的学生，但是学生号也可以决定唯一的学生
- 传递函数依赖
  - 设 R 为任一给定关系， X Y Z 为其不同的属性子集，若 X —> Y, Y 不决定 X 且 Y —>Z，则有 X —>Z，称为 Z 传递函数依赖于 X
  - 例如：书的出版编号是唯一，版权归出版社所有，所以只能由该出版社出版。所以存在函数依赖：书出版编号—>出版社名，出版社名—>出版社地址，但是出版社名不能决定唯一的出版书编号，则有出版社地址传递函数依赖于出版书编号

#### 范式

**第一范式：**

若一个关系模式R的所有属性都是不可分的基本数据项，则该关系属于第一范式（1NF）

满足1NF的关系称为规范化的关系，否则为非规范化关系

**第二范式：**

每一个非主属性都完全依赖于主关键字，而不是部分依赖，则该关系属于第二范式（2NF）

若关系模式R属于1NF，且R中全部是主属性，则R必定是2NF

若关系模式R属于1NF，且R中所有的候选关键字全部是单属性构成，则R必定是2NF

二元关系模式必必定是2NF

**第三范式：**

每一个非主属性都不传递依赖于关键字，则该关系属于第三范式（3NF）

若关系模式R属于1NF，且R中全部是主属性，则R必定是3NF

**BCNF**：

关系模式R是1NF，且每个属性都不传递函数依赖于R的候选关键字，则该关系属于BCNF

二元关系模式必定是BCNF

都是主属性的关系模式并非一定属于BCNF

**非范式化：**

在一个表格中有意义地引入冗余以改进性能被称为非范式化。

##  MySQL存储引擎与数据库操作管理

### 存储引擎

存储引擎即如何存储数据、如何为存储的数据建立索引和如何更新、查询数据的机制

在关系数据库中数据的存储以表的形式存储，所以存储引擎也可以称为表类型

MySQL提供插件式的存储引擎

```sql
--查看当前MySQL数据库支持的存储引擎
SHOW ENGINES ;
SHOW ENGINES \G
--查看当前数据库存储引擎
SHOW VARIABLES LIKE '%storage_engine%'
```

#### InnoDB存储引擎（OLTP）

InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键

- InnoDB给MySQL提供具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎
- InnoDB是为处理巨大数据量提供最大性能而设计的
- InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池
- InnoDB支持外键完整性约束
- InnoDB被用在众多需要高性能的大型数据库站点上

#### MyISAM存储引擎（OLAP)

MyISAM拥有较高的插入、查询速度，但不支持事务

- 大文件（达63位文件长度）
- 当把删除和更新及插入操作混合使用时，动态尺寸的行产生更少碎片
- 每个MyISAM表最大索引数时64，可以通过重新编译来改变
- BLOB和TEXT列可以被索引
- NULL值被允许在索引的列中，占每个键的0或1个字节
- 所有数字键值以高字节优先为原则被存储，以允许一个更高的索引压缩
- MyISAM类型表的`AUTO_INCREMENT`列更新比InnoDB类型的`AUTO_INCREMENT`更快
- 可以把数据文件和索引文件存储在不同的目录
- 每个字符列可以有不同的字符集
- `VARGHAR`的表可以固定或动态地记录长度

使用该引擎会生成三个文件 ：  .FRM  .MYD  .MYI

#### MEMORY存储引擎

适合用于存储临时数据的临时表，以及数据仓库中的维度表（默认使用哈希索引）

- 每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度
- 执行HASH和BTREE索引
- 在一个MEMORY表中可以有非唯一键
- 表使用一个固定的记录长度格式
- 不支持`BLOB`和`TEXT`列
- 支持`AUTO_INCREMENT`列和对可包含`NULL`值的列的索引

#### MERGE存储引擎

是一组MyISAM表的组合，这些表必须结构完全相同，MERGE表本身没有数据。查询、更新、删除实际是对内部的MyISAM表进行

对MERGE表进行`DROP`操作，只是删除MERGE定义，对内部的表没有影响

#### BLACKHOLE存储引擎

不能存储数据，会记录Binlog（二进制日志）

- 验证存储文件语法的正确性
- 来自二进制日志记录的开销测量，通过比较，允许与禁止二进制日志功能的BLACKHOLE的性能
- 用来查找与存储和引擎自身不相关的性能瓶颈

#### CSV存储引擎

该引擎实际上操作的就是一个标准的CSV文件，不支持索引

#### ARCHIVE存储引擎

主要用于通过较小的存储空间来存储过期的很少访问的历史数据

不支持索引

不支持删除，修改操作，仅支持插入和查询操作    行级锁定

#### 选择

MyISAM：适用于不需要事务支持、并发相对较低、数据修改相对较少、以读为主、数据一致性要求不是非常高

InnoDB：适用于需要事务支持，行级锁定对高并发有很好的适应能力，但需要确保查询时通过索引完成的，数据更新较为频繁

MEMORY：适用于需要很快的读写速度、对数据的安全性要求较低的场景

### 字符集

```sql
SHOW CHARACTER SET       --查看所有可以使用的字符集
information_schema. CHARACTER_SETS   --显示所有的字符集和对应的校对规则

SHOW COLLATION LIKE '***'    --查看相关字符集的校对规则
```

MySQL字符集包括**字符集**和**校对规则**

字符集和校对规则是一对多的关系，两个不同的字符集不能有相同的校对规则

每个字符集有一个默认校对规则，每个字符集至少对应一个校对规则

#### 选择

- 应用处理的语言种类多，选择Unicode字符集，MySQL选择UTF-8
- 应用中涉及已有数据的导入，若已有数据为GBK文字，选择UTF-8
- 数据库只需支持一般中文，数据量大，性能要求高，选择GBK
- 数据库需要做大量的字符运算，选择定长字符集
- 考虑客户端所使用的字符集编码格式

#### 设置

服务器字符集和校对规则

```sql
SHOW VARIABLES LIKE 'character_set_server'    --查询当前服务器字符集
SHOW VARIABLES LIKE 'collation_server' 		  --查看校对规则

mysqld -character-set-server=gbk              --启动时指定字符集为gbk
```

数据库字符集和校对规则

```sql
ALTER DATABASE									  --修改字符集
SHOW VARIABLES LIKE 'character_set_database'      --查询当前数据库字符集
SHOW VARIABLES LIKE 'collation_database' 		  --查看校对规则
```

表字符集和校对规则

```sql
ALTER TABLE					--修改字符集
SHOW CREATE TABLE 表名       --查看当前表的字符集和校对规则
```

列字符集和校对规则

针对相同的表不同字段需要使用不同字符集的情况

### MySQL数据库操作管理

#### 数据库

##### 创建

```sql
CREATE DATABASE [IF NOT EXISTS] db_name       --创建数据库
SHOW DATABASES								  --查看所有的数据库
SHOW CREATE DATABASE 数据库名称 \G			   --查看数据库详细信息
```

##### 修改

数据库名称可以进行修改，当存储引擎为MyISAM时，修改DATA目录下的库名文件夹，若存储引擎为InnoDB，无法修改库名

```sql
ALTER DATABASE [db_name]					
[DEFAULT CHARACTER SET charset_name] 		--修改数据库字符集
| [[DEFAULT] COLLATE collation_name]		--修改数据库校对规则

SHOW CREATE DATABASE db_name				--查看数据库详细信息
```

##### 删除

```sql
DROP DATABASE [IF EXISTS] db_name   		--删除数据库
```

## MySQL表定义与完整性约束控制

### 表

数据库由各种数据表组成，数据表是用来存储和操作数据的逻辑结构

- 每个表应该只包含关于一个主题的信息
- 表中不应包含重复信息

### 数据类型

##### 数值数据类型：

- 整数类型：`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`、`BIGINT`

  | **MySQL数据类型** | **含义（有符号）**                                          |
  | ----------------- | ----------------------------------------------------------- |
  | TINYINT(m)        | 1个字节 范围(-128~127)                         小整数值     |
  | SMALLINT(m)       | 2个字节 范围(-32768~32767)                大整数值          |
  | MEDIUMINT(m)      | 3个字节 范围(-8388608~8388607)       大整数值               |
  | INT(m)            | 4个字节 范围(-2147483648~2147483647)               大整数值 |
  | BIGINT(m)         | 8个字节 范围(+-9.22*10的18次方)          极大整数值         |

- 浮点数类型：`FLOAT`、`DOUBLE`

  | **MySQL数据类型** | **含义**                                      |
  | ----------------- | --------------------------------------------- |
  | FLOAT(m,d)        | 单精度浮点型 8位精度(4字节) m总个数，d小数位  |
  | DOUBLE(m,d)       | 双精度浮点型 16位精度(8字节) m总个数，d小数位 |

- 定点小数类型：`DECIMAL`

  浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。

  | **MySQL数据类型** | **含义**                                 |
  | ----------------- | ---------------------------------------- |
  | DECIMAL(m,d)      | 参数m<65 是总个数，d<30且 d<m 是小数位。 |

##### 日期/时间类型：

- `YEAR`、`TIME`、`DATE`、`DATETIME`、`TIMESTAMP`

    | **MySQL数据类型** | **含义**                      |
    | ----------------- | :---------------------------- |
    | DATE              | 日期 '2008-12-2'              |
    | TIME              | 时间 '12:25:36'               |
    | DATETIME          | 日期时间 '2008-12-2 22:06:44' |
    | TIMESTAMP         | 自动存储记录修改时间          |
    | YEAR              | 年份值                        |

##### 字符串类型：

- `CHAR`、`VARCHAR`、`BINARY`、`VARBINARY`、`BLOB`、`TEXT`、`ENUM`、`SET`

  | **MySQL数据类型** | 大小                | 用途             |
  | ----------------- | ------------------- | ---------------- |
  | CHAR              | 0-255字节           | 定长字符串       |
  | VARCHAR           | 0-255字节           | 变长字符串       |
  | TINYTEXT          | 0-255字节           | 短文本字符串     |
  | TEXT              | 0-65 535字节        | 长文本数据       |
  | MEDIUMTEXT        | 0-16 777 215字节    | 中等长度文本数据 |
  | LONGTEXT          | 0-4 294 967 295字节 | 极大文本数据     |

##### 二进制类型：

- `BIT`、`BINARY`、`VARBINARY`、`TINYBLOB`、`BLOB`、`MEDIUMBLOB`、`LONGBLOB`

  | **MySQL数据类型** | 大小                | 用途                            |
  | ----------------- | ------------------- | ------------------------------- |
  | TINYBLOB          | 0-255字节           | 不超过 255 个字符的二进制字符串 |
  | BLOB              | 0-65 535字节        | 二进制形式的长文本数据          |
  | MEDIUMBLOB        | 0-16 777 215字节    | 二进制形式的中等长度文本数据    |
  | LOGNGBLOB         | 0-4 294 967 295字节 | 二进制形式的极大文本数据        |

##### 选择：

- 在符合应用要求（取值范围、精度）的前提下，尽量使用“短”数据类型
- 数据类型越简单越好
- 尽量采用精确小数类型，而不采用浮点数类型
- 使用内置的日期和时间数据类型，而不是使用字符串来存储
- 尽量避免`NULL`字段，建议将字段指定为`NOT NULL` 约束

### 运算符

##### 算术运算符：

| 算术运算符 | 说明               |
| ---------- | ------------------ |
| +          | 加法运算           |
| -          | 减法运算           |
| *          | 乘法运算           |
| /          | 除法运算，返回商   |
| %          | 求余运算，返回余数 |

##### 比较运算符：

| 比较运算符        | 说明                               |
| ----------------- | ---------------------------------- |
| =                 | 等于                               |
| <                 | 小于                               |
| <=                | 小于等于                           |
| >                 | 大于                               |
| >=                | 大于等于                           |
| <=>               | 安全的等于，不会返回 UNKNOWN       |
| <> 或!=           | 不等于                             |
| IS NULL 或 ISNULL | 判断一个值是否为 NULL              |
| IS NOT NULL       | 判断一个值是否不为 NULL            |
| LEAST             | 当有两个或多个参数时，返回最小值   |
| GREATEST          | 当有两个或多个参数时，返回最大值   |
| BETWEEN AND       | 判断一个值是否落在两个值之间       |
| IN                | 判断一个值是IN列表中的任意一个值   |
| NOT IN            | 判断一个值不是IN列表中的任意一个值 |
| LIKE              | 通配符匹配                         |
| REGEXP            | 正则表达式匹配                     |

###### 正则匹配：

- ’ ^ ’  匹配以该字符后面的字符开头的字符串
- ‘ $ ’  匹配以该字符前面的字符结尾的字符串
- ‘ . '   匹配任何一个单字符
- “ [ … ] ”  匹配在方括号内的任何字符        如” [ abc ] “ 表示匹配a、b或c        范围可用’ - ‘ 表示        如“ [ a-z ] "  表示匹配任意字母
- ’ * ’  匹配零个或多个在其前面的字符       如” x* “ 表示匹配任意数量的” x ” 字符

##### 逻辑运算符

| 逻辑运算符   | 说明                           |
| ------------ | ------------------------------ |
| NOT 或者 !   | 逻辑非                         |
| AND 或者 &&  | 逻辑与                         |
| OR 或者 \|\| | 逻辑或                         |
| XOR          | 逻辑异或（相同为零，相异为一） |

##### 位运算符：

| 位运算符 | 说明                   |
| -------- | ---------------------- |
| \|       | 按位或                 |
| &        | 按位与                 |
| ^        | 按位异或               |
| <<       | 按位左移               |
| >>       | 按位右移               |
| ~        | 按位取反，反转所有比特 |

### 数据表操作

#### 创建

```sql
USE<数据库名>											--使用数据库
CREATE TABLE [IF NOT EXISTS] table_name(			   --创建表
	属性名 属性值
	id int(4) NOT NULL UNIQUE COMMENT '编号'，
)
```

#### 查看

```sql
SHOW  TABLES					--查看数据库所有表名

--查看表的结构
DESCRIBE 表名
DESC  表名	
SHOW CREATE TABLE 表名           --不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码
```

#### 修改

```sql
--修改表名
ALTER TABLE<旧表名> RENAME [TO] <新表名>
--修改字段数据类型
ALTER TABLE<表名> MODIFY <字段名> <数据类型>
--修改字段名
ALTER TABLE<表名> CHANGE <旧字段名> <新字段名> <新数据类型>
--添加数据表字段
ALTER TABLE<表名> ADD <新字段名> <数据类型> [约束条件] [FIRST|AFTER 已经存在的字段名]
--删除字段
ALTER TABLE<表名> DROP <字段名>
--修改字段排序
ALTER TABLE<表名> MODIFY <字段1> <数据类型> FIRST|AFTER <字段2>
--更改表的存储引擎
ALTER TABLE<表名> ENGINE =<更改后的存储引擎名>
--删除表的外键约束
ALTER TABLE<表名> DROP FOREIGN KEY <外键约束名>
```

#### 复制

```sql
--复制表的结构和数据
CREATE TABLE [IF NOT EXISTS] table_name
[ () LIKE old_table_name[] ]							--选择表
| [AS (select_statement)]                               --选择字段
```

#### 删除

```sql
DROP TABLE[IF EXISTS] 表1，表2……						  --删除表
SHOW TABLES 											--查看全部表
```

### 约束控制

#### 数据完整性约束

- 实体完整性：强制表的标识符列或主键的完整性
- 参照完整性：在删除和输入记录是，引用完整性保持表之间已定义的关系，确保键值在所有表中一致（不能引用不存在的值）
- 域完整性：限制类型、格式、可能值范围（外键约束、检查约束、默认值约束、非空约束和规则）
- 用户自定义完整性：用户自己定义的业务规则

#### 字段约束

##### 主键约束：

主键分为：单字段主键和多字段联合主键

任何主键字段的值不允许为`NULL`

```sql
PRIMARY KEY(字段名) 							--设置单字段主键
PRIMARY KEY(字段名1，字段名2)					 --设置多字段联合主键
ALTER TABLE 表名 DROP PRIMARY KEY , ADD PRIMARY KEY(字段名)			--修改主键（先删除原来的主键，增加新主键）
```

##### 外键约束：

外键取值 `NULL` 或者为关联表对应字段的值

主表（父表）与从表（子表）之间，以关联值为关键字，建立相关表的联系

子表的记录“参照”父表的记录，则父表的该记录不能删除（`DELETE`）或修改（`UPDATE`）

插入（`INSERT`）或者修改（`UPDATE`）子表的“外键值”，子表的“外键值”必须为父表的“主键值”或 `NULL`

```sql
--表级完整性
FOREIGN KEY(表A的字段名列表) REFERENCES 表B(字段名列表)        
[ ON DELETE { CASCADE|RESTRICT|SET NULL|NO ACTION } ]
[ ON UPDATE { CASCADE|RESTRICT|SET NULL|NO ACTION } ]

/*
CASCADE：父表记录的删除或修改会自动删除或修改子表中对应的记录
RESTRICT:与NO ACTION 功能相同，为级联默认选项
SET NULL:父表记录的删除或修改会将子表中对应的外键值设置为NULL
NO ACTION:父表执行记录的删除或修改时，若子表存在对应记录，操作失败
*/
	--若表已创建
	ALTER TABLE table_name   
	ADD [CONSTRAINT 外键名] FOREIGN KEY [id] (index_col_name,……)
	REFERENCES table_name(index_col_name,……)
	[ ON DELETE { CASCADE|RESTRICT|SET NULL|NO ACTION } ]
	[ ON UPDATE { CASCADE|RESTRICT|SET NULL|NO ACTION } ]
	--若表未创建
	CREATE TABLE 表名(
	index_col_name  数据类型  约束,
	……,
	FOREIGN KEY(index_col_name) REFERENCES 表名(index_col_name)
	)
--列级完整性
CREATE TABLE 表名(
	index_col_name  数据类型 约束 REFERENCES 表名(index_col_name),     --直接在字段后添加REFERENCES命令
	……,
```

##### 非空约束：

设置某个字段的非空约束，即该字段不能为`NULL`

```sql
字段名 数据类型 NOT NULL
```

##### 唯一约束：

要求该列唯一，允许为空，但只能出现一个空值

```sql
字段名 数据类型 UNIQUE 
```

`UNIQUE` 和`PRIMARY KEY` 的区别：一个表中可以有多个字段声明为`UNIQUE`且允许空值，只能有一个`PRIMARY KEY` 声明且不允许空值

##### 默认约束：

若某字段满足默认值约束要求，可以向该字段添加默认值约束

```sql
字段名 数据类型 [其他约束条件] DEFAULT 默认值
```

##### 自增约束：

希望在每次插入新记录时，系统自动生成字段的主键值

一个表中只能有一个字段使用`AUTO_INCREMENT`约束，且该字段必须为主键的一部分

```sql
字段名 数据类型 [其他约束条件] AUTO_INCREMENT
```

##### 检查约束：

设置检查约束直接在数据类型后加约束

```sql
字段名 数据类型 [其他约束条件] CHECK(检查条件)
```

#### 删除约束

```sql
ALTER TABLE 表名 DROP 约束条件  字段名 
```

## MySQL数据操作管理

### 插入数据

```sql
--为表的所有字段插入数据
INSERT INTO 表名 VALUES(值1，值2，……，值n)              --不指定具体的字段名
INSERT INTO 表名(字段名1，字段名2，……，字段名n) VALUES(值1，值2，……，值n)        --列出所有字段，每个值必须与相应字段对应
--为表的指定字段插入字段
INSERT INTO 表名(字段名1，字段名2，……，字段名m) VALUES(值1，值2，……，值n)
--同时插入多条记录
INSERT INTO 表名[(字段名列表)] VALUES(取值列表1)，(取值列表2)，……，(取值列表n)   
--从目标表中插入值
INSERT INTO 表名[列名列表] SELECT 列名列表 FROM 表名 
--REPLACE语句
REPLACE [INTO] 表名 VALUES(值列表)     --若新纪录的主键值或唯一性约束字段值已有记录相同，则已有记录被删除后再添加新纪录
```

### 修改数据

```sql
UPDATE 表名 SET 字段名1=取值1，字段名2=取值2，……，字段名n=取值n  where 条件表达式
```

### 删除数据

```sql
--使用DELETE删除表数据
DELETE FROM 表名 [WHERE 条件表达式]      --DELETE 语句不加上“WHERE 条件表达式” ，数据库系统会删除指定表中的所有数据
--使用TRUNCATE清空表数据
TRUNCATE [TABLE] 表名                  --TRUNCATE TABLE不带WHERE子句与DELETE语句相同
--TRUNCATE TABLE清空表记录后会重新设置自增型字段的计数起始值为1，DELETE会依次递增
```

- `TRUNCATE TABLE`：删除内容、释放空间但不删除定义
- `DELETE TABLE`：删除内容不删除定义，不释放空间
- `DROP TABLE`：删除内容和定义，释放空间

### 单表查询

#### SELECT语法

```sql
SELECT 字段列  		--指定要查询的列名称，列与列之间用逗号隔开。 ALL显示所有行包括重复行，DISTINCT显示所有行(无重复)
FROM <表名或视图名>	  --指定表，表与表之间用逗号隔开			
[WHERE <条件表达式>]    --指定查询条件，无WHERE子句，查询所有记录
[GROUP BY<列名1>]      --对查询结构进行分组
[HAVING <条件表达式>]   --指定分组条件
[ORDER BY<列名2>[ ASC|DESC]]         --对查询结果排序。ASC升序，DESC降序，默认为ASC
[LIMIT 子句]           --限制查询输出结果的行数


--查询所有记录
SELECT *FROM 表名
--避免重复数据查询
SELECT DISTINCT 字段列 FROM 表名
--为表和字段取别名
SELECT 字段名 [AS] 别名，字段名 [AS] 别名…… FROM 表名
```

#### 条件查询

```sql
SELECT * FROM 表名 WHERE 条件;	
--带IN关键字的查询
[NOT] IN (元素1，元素2，……)			--判断字段的值是否在集合内
--带BETWEEN AND关键字的查询
[NOT] BETWEEN 取值1 AND 取值2         --判断字段的值是否在指定范围内         范围包含两端    NOT范围小于取值1，大于取值2
--带IS NULL关键字的查询
IS [NOT] NULL 						--判断字段的值是否为空值
--带LIKE关键字的查询
[NOT] LIKE '字符串'                  --匹配字符串是否相等      '字符串'可以是一个完整的字符串，也可以是通配符
									--% 代表任意长度的字符串，长度可以为0
									--_ 只能表示单个字符
									--正则匹配  REGEXP关键字    属性名 REGEXP '匹配方式'
	--LIKE与REGEXP的区别：
			LIKE匹配整个列，如果被匹配的文本仅在列值中出现，LIKE并不会找到它，相应的行也不会返回
			REGEXP 在列值内进行匹配，如果被匹配的匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回
			Like必须这个字段的所有内容满足条件，而REGEXP只需要有任何一个片段满足即可
```

#### 高级查询

##### 分组查询

```sql
GROUP BY 字段名				--将查询结果按字段分组，字段值相等的为一组，单独使用只显示一个分组的一个记录  
[HAVING 条件表达式]			   --限制分组后的显示，满足条件表达式的结果显示			 
[WITH ROLLUP] 				  --在所有记录最后加上一条记录，为上面所有记录的总和
```

`HAVING`，`WHERE`都是用来限制显示的

- `WHERE`：作用于表或者视图，是表和视图的查询条件
- `HAVING`：作用于分组后的记录，用于选择满足条件的组

##### 对查询结果排序

```sql
ORDER BY 字段名[ASC|DESC]
```

##### 限制查询结果数量

```sql
LIMIT {[OFFSET,] row_count|row_count OFFSET OFFSET}   --OFFSET默认为0
例：返回第3条记录后3条记录
SELECT *FROM 表名 ORDER BY 字段名 LIMIT 2,3
```

##### 聚合函数

聚合函数与`GROUP BY` 联合使用

- `COUNT`：统计记录的条数
- `SUM`：计算字段值的总和
- `AVG`：计算字段值的平均值
- `MAX`：查询字段的最大值
- `MIN`：查询字段的最小值

`SUM`、`AVG`、`MAX`、`MIN`规则

> 列只有`NULL`，函数值为`NULL`
>
> 列某些值为NULL，则函数值为非`NULL`值得平均值除以非`NULL`值的数量

`COUNT`

> ```sql
> COUNT ({[ALL | DISTINCT] <表达式>} | *)     --统计列中非NULL的数量
> 例：统计表中不同字段值的记录数
> SELECT 字段名,COUNT(*) AS '别名'  FROM  表名  GROUP BY  字段名
> ```

`SUM`

> `SUM`函数只能计算数值类型的字段
>
> 使用`SUM`函数计算字符类型字段时，计算结果都为0

##### 合并查询结果

```sql
SELECT ……
UNION [ ALL | DISTINCT]
SELECT ……
[UNION [ ALL | DISTINCT]
SELECT ……
```

不使用ALL关键字，则返回所有行都是唯一的

### 多表查询

- `INNER JOIN`操作：用于组合两个表中的记录。只要公共字段有相符的值，内部链接组合两个表的记录
- `LEFT JOIN`操作：用于在任何`FROM`子句中组合来源表的记录。左边外部连接包含从第一个开始的两个表中的全部记录，即使第二个表中并没有相符的值
- `RIGHT JOIN`操作：用于在任何`FROM`子句中组合来源表的记录。右边外部连接包含从第二个开始的两个表中的全部记录，即使第一个表中并没有相符的值

多表查询使用连接查询，操作效率较低

#### 内连接查询

两表关系的笛卡尔积数据记录中，保留匹配数据，删除不匹配数据

1. 等值连接(INNER JOIN)：连接条件的连接运算符为=时，为等值连接

   ```sql
   SELECT *FROM 表1 INNER JOIN 表2  ON 表1.字段=表2.字段   LIMIT 显示行数
   ```

2. 自然连接(NATURAL JOIN)：在等值连接中把重复列删去

   ```sql
   SELECT *FROM 表1 NATURAL JOIN 表2  LIMIT 显示行数
   ```

 3. 不等值连接(INNER JOIN)：连接条件的连接运算符不为=时，为不等值连接

    ```sql
    SELECT *FROM 表1 INNER JOIN 表2  ON 表1.字段!=表2.字段   LIMIT 显示行数
    ```

#### 外连接查询

外连接查询可以查询**两个或两个以上**的表

1. 左外连接(LEFT JOIN)：左表记录中按照条件与右表进行连接，右表无响应数据返回`NULL`
2. 右外连接(RIGHT JOIN)：右表记录中按照条件与左表进行连接，左表无响应数据返回`NULL`

![image-20201223190010045](C:\Users\24394\AppData\Roaming\Typora\typora-user-images\image-20201223190010045.png)

> 左外连接：其运算方式为：A左连接B的记录=图公共部分记录集C＋表A记录集A1。
>
> 右外连接：其运算方式为：A右连接B的记录=图公共部分记录集C＋表B记录集B1 。

#### 子查询

```sql
--带IN关键字的子查询
SELECT * FROM 表1 WHERE 字段1 [NOT] IN (SELECT 字段1 FROM 表2)
--带EXISTS关键字的子查询
SELECT * FROM 表1 WHERE EXISTS (SELECT *FROM 表2 WHERE 字段='给定值')
		--EXISTS内循环返回一个真假值，真执行外查询，假不执行
--带ANY关键字的子查询
SELECT * FROM 表1 WHERE 字段1 运算符 ANY(条件)    --满足任何一个条件
--带ALL关键字的子查询
SELECT * FROM 表1 WHERE 字段1 运算符 ALL(条件)     --满足所有条件
```

> `ALL`、`ANY`：
>
> 大于`ALL`表示大于条件内最大值
>
> 小于`ALL`表示小于条件内最小值
>
> 大于`ANY`表示大于条件内最小值
>
> 小于`ALL`表示小于条件内最大值

## MySQL索引

### 索引

创建索引的目的是为了优化数据库的查询速度

所有MySQL列类型都可以被索引，对相关列使用索引是提高`SELECT`操作性能的**最佳途径**

索引的两种存储类型：**B型树索引**，**哈希索引**

索引的优点

- 通过创建唯一性索引，可以保证数据库数据的唯一性
- 大大加快数据的检索速度
- 加速表之间的连接
- 使用分组和排序子句进行数据检索时，可以显著减少查询时间
- 通过使用索引，在查询过程可以使用优化隐藏器，提高系统性能

索引的缺点

- 创建索引和维护索引耗时，随数据量增加而增加
- 索引占据一定的物理空间
- 对表中的数据进行增删改时，索引也要动态维护，降低了数据的维护速度

索引的特征：**唯一性索引**，**复合索引**

> 唯一性索引保证在索引列中的全部数据唯一，不包含冗余数据。
>
> 当表中有主键约束或唯一性键约束，当创建表或MySQL自动创建一个唯一性索引
>
> 当修改非空表中数据时，存在唯一性索引，表中存在冗余值，则修改操作失败

> 复合索引将一个索引创建在两个列或多列上
>
> 最多16个列合并为一个复合索引，列的总长度不超过900字节
>
> 复合索引的列必须来自同一个表
>
> 首先定义最唯一的列

索引的分类

- 普通索引：在创建普通索引时，不附加任何限制条件
- 唯一性索引：使用`UNIQUE`参数设置。通过唯一性索引，可以更快速地确定某条记录。**主键就是一种特殊唯一性索引**
- 全文索引：使用`FULLTEXT`参数设置。只能创建在`CHAR`、`VARCHAR`、`TEXT`类型字段。查询数据量较大地字符串类型字段使用
- 单列索引：在表中地**单个字段**上创建一个索引。单列索引只根据该字段进行索引，可以是以上三种索引
- 多列索引：在表中地**多个字段**上创建一个索引。查询条件只有带有第一个字段，索引才会被使用
- 空间索引：使用`SPATIAL`参数设置。只能创建在`GEMETRY`、`POINT`、`LINESTRING`、`POLYGON`这些空间类型上，值不能为`NULL`

### 索引的定义和管理

#### 创建索引

直接创建：

- 创建表时创建索引

  ```sql
  CREATE TABLE table_name(
  	属性名，数据类型[完整性约束]，
  	属性名，数据类型[完整性约束]，
  	……
  	INDEX | KEY [索引名](属性名[(长度)] [ASC|DESC])
  
  )
  ```

- 在已存在的表上创建索引

  ```sql
  CREATE INDEX 索引名 ON 表名 (属性名 [ (长度) ] [ASC|DESC])
  ```

- 使用`ALTER TABLE`语句创建索引

  ```sql
  ALTER TABLE table_name ADD INDEX | KEY [索引名](属性名[(长度)] [ASC|DESC])
  ```

间接创建：

​	表中定义主键约束或唯一性键约束时，同时创建索引

​	若表中已有使用`CREATE INDEX`创建的标准索引时，由主键约束或唯一性键约束创建的索引会覆盖之前的标准索引

##### 普通索引

```sql
EXPLAIN SELECT *FROM 表名 WHERE 字段='字段值'        --查看索引是否被使用，查看使用哪个索引
--使用ALTER TABLE在字段1的前五个记录上创建降序排序
ALTER TABLE 表名 ADD INDEX 索引名 (字段1(5) DESC)
--指定使用索引1用于字段查询
SELECT *FROM 表名 USE INDEX FOR JOIN(索引1) WHERE 字段='查询值'
```

##### 唯一索引

```sql
--使用CREATE INDEX 命令在表1的字段1上创建唯一性索引
CREATE UNIQUE INDEX 索引名 ON 表1(字段1)
--使用ALTER TABLE 命令在表1的字段1上创建唯一性索引
ALTER TABLE 表1 ADD UNIQUE INDEX (字段1)
```

##### 全文索引

```sql
--例：创建表1，并指定char(20)字段类型的字段1为全文索引
CREATE TABLE 表1(
	属性名，数据类型[完整性约束]，
	……
	字段1 CHAR(20),
	FULLTEXT INDEX 索引名(字段1)

);
```

##### 多列索引

```sql
--例：创建表1，并指定char(20)字段类型的字段1和int类型的字段2上创建多列索引
CREATE TABLE 表1(
	属性名，数据类型[完整性约束]，
	……
	字段1 CHAR(20),
	字段2 INT ，
	INDEX 索引名(字段1，字段2);
```

#### 查看索引

```sql
SHOW INDEX | KEY FROM table_name [FROM db_name]
```

`SHOW INDEX` 返回信息：

| 参数         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| Table        | 表示创建索引的数据表名。                                     |
| Non_unique   | 表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。 |
| Key_name     | 表示索引的名称。                                             |
| Seq_in_index | 表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。 |
| Column_name  | 表示定义索引的列字段。                                       |
| Collation    | 表示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。 |
| Cardinality  | 索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。 |
| Sub_part     | 表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 NULL。 |
| Packed       | 指示关键字如何被压缩。若没有被压缩，值为 NULL。              |
| Null         | 用于显示索引列中是否包含 NULL。若列含有 NULL，该列的值为 YES。若没有，则该列的值为 NO。 |
| Index_type   | 显示索引使用过的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。 |
| Comment      | 显示评注。                                                   |

#### 删除索引

```sql
ALTER TABLE table_name DROP INDEX index_name
ALTER TABLE table_name DROP PRIMARY KEY
DROP INDEX index_name ON table_name
```

第二条语句只删除`PRIMARY KEY`索引，一个表只可能有一个`PRIMARY KEY`索引，因此不需要指定索引名

多列索引，删除其中的某列，则该列也会从索引中删除，组成索引的所有列都被删除，则整个索引被删除

### 设计原则和注意事项

#### 索引的设计原则

- 选择唯一性索引
- 为经常需要排序、分组和联合操作的字段建立索引
- 为常作为查询条件的字段建立索引
- 限制索引的数目
- 尽量使用数据量少的索引
- 尽量使用前缀来索引
- 删除不在使用或很少使用的索引

#### 合理使用索引的注意事项

一般**在**以下列上创建索引

- 在经常需要搜索的列上，可以加快搜索速度
- 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
- 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度
- 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，指定范围时连续的
- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
- 经常使用在`WHERE`子句中的列上创建索引，加快条件的判断条件

#### 不合理使用索引的注意事项

一般**不在**以下列上创建索引

- 对于在查询中很少使用或者参考的列不应该创建索引
- 对于只有很少数据值的列也不应该增加索引
- 对于定义为`text`、`image`和`bit`数据类型的列不应该增加索引
- 当修改性能远远大于检索性能时，不应该创建索引

## MySQL视图

### 视图

视图是一个虚拟表，**不占据存储空间**，数据来源于数据库表或其他视图，当基本表发生变化时，视图的数据也会变化

当调用视图时，才会执行视图中的SQL语句，进行取数据操作

#### 视图的优势

- 增强数据安全性（不同的用户分配不同的视图）

- 提高灵活性，操作简单

- 提高数据的逻辑独立性

  > 使用视图可以向应用程序屏蔽表结构
  >
  > 使用视图可以向数据库表屏蔽应用程序

### 视图定义和管理

#### 创建与使用：

创建视图需要`CREATE VIEW` 的权限以及`SELECT` 权限

```sql
CREATE [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
VIEW 视图名 [(视图列表)]						--视图名唯一
AS 查询语句									  
[WITH [CASCADED | LOCAL] CHECK OPTION] 		--CASCADED表示更新视图时要满足所有相关视图和表的条件，为默认值
											--LOCAL表示更新视图时，满足该视图本身的定义条件即可

--例：在表1上创建一个名为表1_view的视图，包含字段1，字段2，字段3
CREATE VIEW 表1_view(字段1,字段2,字段3) AS SELECT 字段1,字段2,字段3  FROM 表2，表3，表4 WHERE (条件)
--例：查询给定值的信息
SELECT *FROM 表1_view WHERE 字段1='给定值';
```

当向与视图关联的表中添加新字段，查询时该视图不包括新字段；若与视图关联的表或视图被删除，该视图不能使用

#### 删除

删除视图时，只能删除视图的定义，不会删除数据

```sql
DROP VIEW [IF EXISTS]
view_name[,view_name2]……
[RESTRICT | CASCADE]
```

一次可以删除多个视图

#### 查看

查看视图要有`SHOW VIEW` 的权限

查看方法：

```sql
DESCRIBE 视图名称;      或者DESC 视图名称;
SHOW TABLE STATUS LIKE '视图名'
SHOW CREATE VIEW '视图名'
--查询某数据库下的视图表
SELECT *FROM db_name.views WHERE table_name ='视图名'
```

#### 修改

```sql
CREATE OR REPLACE VIEW 视图名[{属性清单}] AS SELECT 语句 
ALTER VIEW 视图名[{属性清单}] AS SELECT 语句
```

#### 更新

通过视图进行插入(`INSERT`)、更新(`UPDATE`)、删除(`DELETE`)表中的数据

更新视图的语法与`UPDATE`语法一致

## MySQL权限管理

### 权限系统

MySQL可以使用3种不同类型的安全检查

1. 登陆验证：用户名、密码验证
2. 授权：对用户设置其具体权限
3. 访问控制：是否允许操作

存储控制阶段：

1. 服务器检查是否允许连接
2. 若允许连接，服务器检查用户发出请求是否有相应的权限

服务器在存取控制阶段使用user、db、host表

在执行数据库操作时，需要通过root用户账号登录，对整个MySQL服务器具有完全控制

### 权限表

#### user表

user为MySQL中最终的一个权限表，可以使用`DESC`查看user的基本结构

user列分为：用户列、权限列、安全列、资源控制列

权限分为普通权限和管理权限：

> 普通权限：主要用于对数据库的操作
>
> 管理权限：主要用于对数据库进行管理的操作

用户连接时，权限表的存取过程：先从user表中的host、user、password判断来连接的ip、用户名称、密码是否存在，若存在，通过身份验证，否则拒绝连接

通过验证后，按照以下权限顺序得到数据库权限：user、db、table_priv、colums_priv，权限依次递减，全局覆盖局部

##### 用户字段

```sql
--查询user表的相关用户字段
SELECT Host ,User , 'Password' FROM mysql.'user'
```

##### 权限字段

权限字段以`priv`结尾，这些字段决定用户权限

权限字段的值只有`Y`或`N`，表示有权限和无权限，默认值为`N`，可以使用`GRANT`为用户赋予权限

```sql
--查看localhost主机下的用户的select、insert、update权限
SELECT SELECT_priv,insert_priv,update_priv,user,host
FROM mysql.user WHERE host = 'localhost';
```

##### 安全字段

安全字段：ssl_type        ssl_cipher 

​				   x509_issuer    x509_subject      

​					另外两个与授权插件有关

`ssl`可用于加密；`x509`标准可用于标识用户；`plugin`字段标识可用于验证用户身份的插件，若该字段为空，服务器使用内建授权机制验证

```sql
--查看hava_openssl是否具有ssl功能
SHOW VARIABLES LIKE 'hava_openssl';
```

##### 资源控制列

资源控制列用来限制用户使用的资源，有以下字段：

- `max_question`：用户每小时允许执行的查询操作次数
- `max_updates`：用户每小时允许执行的更新操作次数
- `max_connections`：用户每小时允许执行的连接操作次数
- `max_user_connections`：单个用户可以同时具有的连接次数

默认值都为0，表示无限制

#### db表和host表

db表存储用户对某个数据库的操作权限，决定用户能从哪个主机存取哪个数据库

host表存储某个主机对数据库的操作权限

这两权限表不受`GRANT`和`REVOKE`语句影响，可以使用`DESC`语句查看两表的基本结构

##### 用户列

db表的用户列：

- host：主机名
- db：数据库名
- uesr：用户名

host表的用户列：

- host：主机名
- db：数据库名

host为db的扩展，db表找不到host的值，需要到host表中寻找

##### 权限列

db表与host表的权限列大致相同，`create_routine_priv`和`alter_routine_priv`表示用户是否有创建和修改存储过程的权限

当希望用户只对某个数据库有操作权限，则将user表的对应权限设为`N`，在db表设置对应数据库的操作权限

##### tables_priv表

tables_priv表可以对单个表进行权限设置，用来指定表级权限，可以使用`DESC`语句查看两表的基本结构

tables_priv表字段：

- host：主机名
- db：数据库名
- uesr：用户名
- table_name：表名
- grantor：修改该记录的用户
- timestamp：修改该记录的时间
- table_priv：对表进行操作的权限，包括：select、insert、update、delete、create、drop、grant、reference、index、alter
- column_priv：对表中的列进行操作的权限，包括：select、insert、update、reference

#### columns_priv表

columns_priv表可以对表中的某一列进行权限设置

columns_priv表字段：

- host：主机名
- db：数据库名
- uesr：用户名
- table_name：表名
- column_name：指定对哪些数据列具有操作权限
- timestamp：修改该记录的时间
- column_priv：对表中的列进行操作的权限，包括：`select`、`insert`、`update`、`reference`

#### procs_priv表

procs_priv表可以对存储过程和存储函数进行权限设置，可以使用`DESC`语句查看两表的基本结构

procs_priv表字段：

- host：主机名
- db：数据库名
- uesr：用户名
- routine_name：存储过程或存储函数的名称
- routine_type：存储过程或存储函数的类型，该字段有两个值：`function`表示存储函数，`procedure`表示存储过程
- grantor：存储插入或修改该记录的用户
- proc_priv：拥有的权限，包括：execute、alter routine、grant
- timestamp：存储记录更新的时间

### 用户管理

```sql
--查看所有用户账号列表
USE mysql；
SELECT user FROM user；
```

#### 添加用户

新的MySQL数据库系统，只有一个root用户

##### 使用`CREATE USER`语句创建用户账号

```sql
CREATE USER<User_name> [IDENTIFIED BY <password>]
[LOGIN POLICY <policy_name>]
[FORCE PASSWORD CHANGE{ ON | OFF }]
--在MySQL服务器中添加新用户，用户名为zhangsan，主机名为localhost，口令设置为明文123
CREATE USER 'zhangsan'@'localhost' IDENTIFIND BY '123';
```

- `User_name`：指定创建用户账号，格式为：'user_name'@'host name'，user_name为用户名，host name为主机名
- `IDENTIFIED BY`：用于指定用户账号对应的口令，无口令可省略
- `policy_name`：指派给用户的登录策略的名称，无策略可省略
- `password`：为用户指定口令，无口令的用户不能连接数据库

用户ID和口令不能出现以下情况：

- 以空格、单引号、双引号开头
- 以空格结尾
- 含有分号

`CREATE USER`语句使用说明：

- 使用该语句，需要有MySQL数据库的`INSERT`权限或全局`CREATE USER`权限
- 使用该语句创建用户账号后，会在系统自身的user表添加一条新纪录
- 若两个用户具有相同的用户名和不同的主机名，MySQL会视为不同的用户，允许为两个用户分配不同权限
- 使用该语句未指定口令，MySQL允许该用户可以不使用口令登录（不推荐）
- 新创建的用户只允许进行不需要权限的操作，如查询所有存储引擎、字符串的列集等

##### 使用`INSERT`语句新建普通用户

使用`INSERT`语句需要有对user表的插入权限

使用`INSERT`语句至少要插入六个字段的值：host、user、password、ssl_cipher、x09_issuer、x509_subject

```sql
--插入xiaohong用户，主机名为localhost，密码时password(123)
INSERT INTO mysql.user(host,user,password,ssl_cipher,x09_issuer,x509_subject)
	VALUES('localhost','xiaohong',password(123),'','','');
	
--执行上述语句后，要使用’FLUSH PRIVILEGES'使命令生效，需要reload权限
FLUSH PRIVILEGES
```

##### 使用`GRANT`语句新建普通用户

#### 查看用户

```sql
SELECT *FROM mysql.user WHERE host='host_name' AND user='user_name'			--*表示所有列，也可以指定特定列
```

#### 修改用户账号

修改用户账号需要有MySQL数据库的`update`权限或全局`create user`权限

```sql
RENAME USER old_user TO new_user [,old_user TO new_user] ……     --old_user：系统中已存在的用户账号
																--new_user：新的MySQL用户账号
```

#### 修改用户口令

使用`mysqladmin`命令修改密码

```sql
mysqladmin -u username p password，根据提示先输入旧密码，在输入新密码
```

使用`set`语句修改

```sql
SET PASSWORD [FOR 'username'@'hostname']=password('new_password')   --不加FOR……，则修改当前用户密码
--修改xiaohong密码为 '123'
SET PASSWORD [FOR 'xiaohong'@'localhost']=password('123') 
```

修改user表，使用root登录，修改自己或普通用户密码

```sql
UPDATE mysql.user SET password=password('new_password') WHERE user='user_name' AND host='host_name'
--修改xiaohong的密码为 '123456'
UPDATE mysql.user SET password=password('123456') WHERE user='xiaohong' AND host='localhost'
```

每次修改后，需要使用`FLUSH PRIVILEGES`命令重新加载权限

#### 删除用户

使用`DROP USER`语句删除普通用户

```sql
DROP USER user[,user]……
--删除名为xiaohong用户，host值为localhost
DROP USER xiaohong@localhost
```

使用`DELETE`语句删除普通用户

```sql
DELETE FROM mysql.user WHERE user='user_name' AND host='host_name';
```

### 账户权限管理

#### 权限授予

```sql
GRANT priv_type[(column_list)][,priv_type[(column_list)]]……
ON[object_type] priv_level
TO user_sepcification[,user_sepcification]……
[WITH with_option]
--授予用户lili在数据库studentinfo的表student上拥有对列sno和列sname的select权限
GRANT select(sno,sname) ON student TO 'lili'@'localhost'
--不存在用户liming和用户huang，要求创建两个用户同时授予在数据库studentinfo的表student上拥有select和update权限
GRANT select，update ON studentinfo.student TO 
'liming'@'localhost' IDENTIFIED BY '123'
'haung'@'localhost' IDENTIFIED BY '789';
--授予用户lili可以在数据库studentinfo中执行所有操作的权限
GRANT ALL ON studentinfo.* TO 'lili'@'localhost';
```

GRANT 权限级别：

- *：当前数据库中的所有表
- \*.\*：所有数据库的所有表
- db_name.*：某个数据库中的所有表
- db_name.tbl_name：某个数据库的某个表或视图
- tbl_name：某个表或视图
- db_name.routine_name：某个数据库中的某个存储过程或函数

GRANT中priv_type值：

- `select`：授予用户可以使用`SELECT`语句访问特定表的权限
- `insert`：授予用户可以使用`INSERT`语句从一个特定表中添加数据行的权限
- `delete`：授予用户可以使用`DELETE`语句从一个特定表中删除数据行的权限
- `update`：授予用户可以使用`UPDATE`语句修改特定表中值的权限
- `reference`：授予用户可以创建一个外键来参照特定数据表的权限
- `create`：授予用户可以使用特定的名字创建一个数据表的权限
- `alter`：授予用户可以使用`ALTER TABLE`语句修改数据表的权限
- `index`：授予用户可以在表上定义索引的权限
- `drop`：授予用户可以删除数据表的权限
- `all`或`all privileges`：所有的权限

授予列权限时，只能使用`select`、`insert`、`update`，权限还要加上列名列表`colimn_list`

#### 权限的转移和限制

通过`GRANT`语句中使用`WITH`子句实现

转移权限

将`WITH`子句指定为`WITH GRANT OPTION`,表示`TO`子句中所指定的所有用户都具有把自己权限授予其他用户的权利

限制权限

若`WITH`子句中`WITH`关键字后为以下四项，即拥有限制权限

- `max_queries_per_hour count`：限制每小时可以查询数据库的次数
- `max_updates_per_hour count`：限制每小时可以修改数据库的次数
- `max_ccconnections_per_hour count`：限制每小时可以连接数据库的次数
- `max_user_connection count`：限制同时连接MySQL的最大用户数，`count`为用户数

```sql
--授予系统中的用户huang在数据库studentinfo的表student上每小时只能处理一条delete语句的权限
GRANT delete ON studentinfo.student TO 'huang'@'localhost' WITH max_queries_per_hour 1;
```

#### 权限的撤销

使用`REVOKE`语句，要有MySQL数据库的全局`CREATE user`权限或`UPDATE`权限

```sql
--回收某些特定的权限
REVOKE priv_type[(column_list)][,priv_type[(column_list)]]……
ON[object_type] priv_level
FROM user[,user]……
--回收特定用户的所有权限
REVOKE ALL PRIVILECES,GRANT OPTION
FROM user[,user]……
```

